# ==================================================
# author:luojiajie
# ==================================================

import os
import csv
import numpy as np
import matplotlib.pyplot as plt


class exploitation():
    """
    usage: generate a set of points around the point of max error for all surrogate models in self.surro_list

    note: this module must run after running cross validation for the surrogate model, so that point of max error is got
    """
    def __init__(self,surro_list):
        self.surro_list = surro_list # surrogate model object list
        self.exploitation_X = None # additional samples generated by exploitation of all surrogate models
        self.exploitation_X_single_surro = None # additional samples generated by exploitation of single surrogate model

    def read_csv_to_np(self,file_name):
        """
        read data from .csv and convert to numpy.array
        note: if you use np.loadtxt(), when the data have only one row or one column, the loaded data is not in the desired shape
        """
        csv_reader = csv.reader(open(file_name))
        csv_data = []
        for row in csv_reader:
            csv_data.append(row)

        row_num = len(csv_data)
        col_num = len(csv_data[0])

        data = np.zeros((row_num, col_num))
        for i in range(row_num):
            data[i, :] = np.array(list(map(float, csv_data[i])))
        return data

    def generate_exploitation_X(self,number):
        """
        :param number: number of additional samples to generate by exploitation for single surrogate model
        """
        surro_ind=0 # surrogate model index of self.surro_list
        while True:
            self.generate_exploitation_X_single_surro(self.surro_list[surro_ind],number) # generate self.exploitation_X_single_surro for single surrogate model in surro_list

            try:
                exploitation_X_tmp=np.vstack((self.exploitation_X,self.exploitation_X_single_surro)) # stack self.exploitation_X_single_surro if i>=1
            except:
                exploitation_X_tmp=self.exploitation_X_single_surro.copy() # stack self.exploitation_X_single_surro for the first surrogate model

            if exploitation_X_tmp.shape[0] == np.unique(exploitation_X_tmp, axis=0).shape[0]:  # if there is no duplicate samples, stack, else, generate again
                self.exploitation_X=exploitation_X_tmp.copy()
                # save surrogate_model.max_test_error as the level of exploitation
                if os.path.exists('level_of_exploitation' + str(surro_ind) + '.csv') == False:
                    np.savetxt('level_of_exploitation' + str(surro_ind) + '.csv', np.array([self.surro_list[surro_ind].max_test_error]), delimiter=',')
                else:
                    level_of_exploitation_old = self.read_csv_to_np('level_of_exploitation' + str(surro_ind) + '.csv')
                    level_of_exploitation = np.vstack((level_of_exploitation_old, np.array([self.surro_list[surro_ind].max_test_error])))
                    np.savetxt('level_of_exploitation' + str(surro_ind) + '.csv', level_of_exploitation, delimiter=',')
                surro_ind += 1

            if surro_ind == len(self.surro_list): # all surrogate model in self.surro_list have completed generate_exploitation_X
                break

        np.savetxt('X_exploitation.csv', self.exploitation_X, delimiter=',')


    def generate_exploitation_X_single_surro(self,surro,number):
        """
        :param surro: single surrogate model in surro_list
        :param number: number of additional samples to generate by exploitation for single surrogate model
        """
        self.exploitation_X_single_surro = np.zeros((number,surro.X.shape[1])) # additional samples generated by exploitation of single surrogate model
        dis_all=np.sum((surro.normalized_X-surro.point_max_error)**2,axis=1)**0.5 # calculate the distance between the point_max_error and all X
        dis_all[dis_all.argmin()]=dis_all.max() # note the point_max_error is also in the X, so the minimum distance is zero. we assign this zero to the maximum value in dia_all so that we can get the minimum distance between the point_max_error and all X
        min_dis=dis_all.min()
        dis_lb = 1 / 3 * min_dis # distance lower bounary. distance between the selected points and surro.point_max_error should larger than this boundary
        dis_ub = 2 / 3 * min_dis # distance upper bounary. distance between the selected points and surro.point_max_error should smaller than this boundary

        i=0
        loop_count=0 # used for count the total loop for the WHILE below
        while True:
            loop_count += 1
            if loop_count >= 3000000:
                # note: if the surro.point_max_error is very close to the boundary, especially for
                # very high dimension problem, it is very hard to find a point within the boundary
                # so if the loop has been run for more than about 3 five minutes, it will break,
                # and then only the surro.point_max_error will be the exploitation point
                # since surro.point_max_error is also in the X, it will be eliminated in the adaptive_sequential_sampling
                # so there will be no exploitation points for these cases
                self.exploitation_X_single_surro = np.zeros((1, surro.X.shape[1]))
                self.exploitation_X_single_surro[0,:]=surro.point_max_error
                break

            rand_vec=np.random.rand(surro.X.shape[1])*2-1 # generate a random vector
            rand_vec_len=np.sum(rand_vec**2)**0.5 # length of random vector
            rand_vec_unit=rand_vec/rand_vec_len # unit random vector
            rand_len=dis_lb+np.random.rand()*(dis_ub-dis_lb) # generate a random length between dis_lb and dis_ub
            new_point=surro.point_max_error + rand_vec_unit * rand_len
            if new_point.max()<=1 and new_point.min()>=0: # the generated points should not exceed the boundary
                self.exploitation_X_single_surro[i,:]=new_point
                i+=1
            if i==number:
                break

        self.exploitation_X_single_surro=surro.inverse_normalize_X(self.exploitation_X_single_surro)
        surro.point_max_error = surro.inverse_normalize_X(np.array([surro.point_max_error])) # inverse normalize point of max error, used for plot
        surro.point_max_error.resize(surro.point_max_error.shape[1])


    def plot(self, y_range=[], outer_iter=0):
        """
        plot scatter of self.exploitation_X_single_surro

        :param y_range: 1. if y_range==[], plot y according to calculated max range of y
                        2. plot y acoording to given range: y_range=[lower boundary, upper boundary, step]
                        e.g. y_range=[0,10,1]
        :param outer_iter: outer iteration index (used for saving the plot of new updated surrogate model)
        """
        if os.path.exists('plot') == False:
            os.makedirs('plot')
        dimension=self.exploitation_X.shape[1]
        # ==================================================
        # 1D
        # ==================================================
        if dimension == 1:
            plt, p1 = self.surro_list[0].plot(self.surro_list[0].lower_bound,self.surro_list[0].upper_bound, y_range, show_flag=0) # get plt and scatter of all samples from surrogate model
            p2 = plt.scatter(self.surro_list[0].point_max_error[0], np.zeros((1,1)), s=50, marker='x',c='black') # plot scatter of point_max_error
            p3 = plt.scatter(self.exploitation_X_single_surro[:,0], np.zeros((self.exploitation_X_single_surro.shape[0],1)), s=50, marker='^', c='none',edgecolors='black') # plot scatter of self.exploitation_X

            # legend
            font = {'family': 'Times New Roman', 'weight': 'normal', 'size': 20, }
            plt.legend(handles=[p1, p2, p3], labels=['all samples', 'max error sample', 'exploitation points'], loc='best', edgecolor='black', prop=font)

        # ==================================================
        # multi dimension
        # ==================================================
        elif dimension >= 2:
            plt, p1 = self.surro_list[0].plot(self.surro_list[0].lower_bound, self.surro_list[0].upper_bound, y_range,
                                      rest_var=self.surro_list[0].point_max_error,
                                      show_flag=0)  # get plt and scatter of all samples from surrogate model

            for i in range(dimension):
                for j in range(dimension - 1, i, -1):
                    col_ind = i  # column index
                    row_ind = -j + dimension - 1  # row index
                    ind = row_ind * (dimension - 1) + col_ind + 1  # subplot index
                    plt.subplot(dimension - 1, dimension - 1, ind)  # locate subplot
                    p2, p3=self.plot_md(i, j)  # plot response surface in subplot
                    # plot axis label
                    fontXY = {'family': 'Times New Roman', 'weight': 'normal', 'size': 30, }  # xy label size
                    axisfont = 20  # axis number size
                    if row_ind == 0 and col_ind == 0:  # first subplot, plot both axis
                        ax = plt.gca()
                        ax.xaxis.set_ticks_position('top')
                        ax.xaxis.set_label_position('top')
                        plt.xlabel('$x_' + str(i+1)+'$', fontXY)
                        plt.ylabel('$x_' + str(j+1)+'$', fontXY)
                    elif row_ind == 0 and col_ind != 0:  # first row, plot x axis label
                        plt.yticks([])
                        ax = plt.gca()
                        ax.xaxis.set_ticks_position('top')
                        ax.xaxis.set_label_position('top')
                        plt.xlabel('$x_' + str(i+1)+'$', fontXY)
                    elif col_ind == 0 and row_ind != 0:  # first column, plot y axis label
                        plt.xticks([])
                        plt.ylabel('$x_' + str(j+1)+'$', fontXY)
                    else:  # other subplot, do not show x,y axis label
                        plt.xticks([])
                        plt.yticks([])
                    plt.xlim(self.surro_list[0].lower_bound[i], self.surro_list[0].upper_bound[i])  # x range
                    plt.ylim(self.surro_list[0].lower_bound[j], self.surro_list[0].upper_bound[j])  # x range
                    plt.tick_params(labelsize=axisfont)  # axis number size

            if dimension > 2: # dimension>2 case, plot legend in subplot
                plt.subplot(2, dimension - 1, 2 * (dimension - 1)) # locate color bar subplot
            # legend
            font = {'family': 'Times New Roman', 'weight': 'normal', 'size': 20, }
            plt.legend(handles=[p1, p2, p3], labels=['all samples', 'max error sample', 'exploitation points'], loc='best', edgecolor='black', prop=font)

        # plt.show()
        plt.savefig('plot/exploitation_'+str(outer_iter)+'.eps')
        plt.close()


    def plot_md(self, x1_arg, x2_arg):
        p2 = plt.scatter(self.surro_list[0].point_max_error[x1_arg], self.surro_list[0].point_max_error[x2_arg], s=50, marker='x',c='black') # plot scatter of point_max_error
        p3 = plt.scatter(self.exploitation_X_single_surro[:,x1_arg], self.exploitation_X_single_surro[:,x2_arg], s=50, marker='^', c='none',edgecolors='black') # plot scatter of self.exploitation_X
        return p2,p3


# e.g.
if __name__ == '__main__':
    # ==================================================
    rootpath = r'E:\ljj\aa\demo'  # your saopy file path
    import sys
    sys.path.append(rootpath)  # you can directly import the modules in this folder
    sys.path.append(rootpath + r'\saopy\surrogate_model')
    sys.path.append(rootpath + r'\saopy')
    # ==================================================
    from saopy.surrogate_model.ANN import *
    # from saopy.surrogate_model.KRG import *
    # from saopy.surrogate_model.RBF import *
    from saopy.surrogate_model.surrogate_model import *

    surro_list=[]
    surro_list.append(load_obj(r'demo\benchmark_surrogate_compare\easom_2D_ANN\best_surro'))
    exploit = exploitation(surro_list)
    exploit.generate_exploitation_X(5)
    exploit.plot([-0.3,0,0.1], outer_iter=0)